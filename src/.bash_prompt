#!/bin/bash

PROMPT_COMMAND=custom_prompt;
EXIT=;
HAS_GIT_PS1="$(test "$(type -t __git_ps1)" = 'function' && echo true || echo false)";
REPO_STATUS=;
IS_ROOT="$(is_root)";

function custom_prompt {
	# fetch exit code of last command
	EXIT="${?}";

	# set shell title to current working directory
	if [ -n "${SSH_TTY}" ]; then
		set_shell_title "${USER}@$(hostname): $(short_pwd)";
	else
		set_shell_title "$(short_pwd)";
	fi;

	# show repo branch
	if [ -d "$(test_path_recursive .git)" ]; then
		if [ "${HAS_GIT_PS1}" == true ]; then
			# use git ps1 if available
			REPO_STATUS="$(__git_ps1 '%s' 2> /dev/null)";
		else
			# default to git command
			REPO_STATUS="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)";
		fi;
		REPO_STATUS="${REPO_STATUS:-.git}";
	elif [ -d "$(test_path_recursive .hg)" ]; then
		REPO_STATUS="$(hg id -b 2> /dev/null)";
		REPO_STATUS="${REPO_STATUS:-.hg}";
	else
		REPO_STATUS=;
	fi;

	custom_ps1;
}

function custom_ps1 {

	# color codes
	local  RESET="\e[0m";
	local  BLACK="\e[30;1m";
	local    RED="\e[0;31m";
	local  GREEN="\e[0;32m";
	local YELLOW="\e[0;33m";
	local   BLUE="\e[0;34m";
	local PURPLE="\e[0;35m";

	# prompt components
	local  OPEN="${BLACK}[${RESET}";
	local CLOSE="${BLACK}]${RESET}";
	local  TIME="${BLUE}\@${RESET}";
	local    AT="${YELLOW}@${RESET}";
	local  HOST="${GREEN}\h${RESET}";
	local   PWD="${PURPLE}\w${RESET}";
	local  USER;
	local   EXT;

	# dim exit code when 0
	if [ -z ${EXIT} ] || [ ${EXIT} == 0 ]; then
		EXT="${BLACK}0${RESET}";
	else
		EXT="${EXIT}";
	fi;

	# show root in red
	if [ "${IS_ROOT}" == true ]; then
		USER="${RED}\u${RESET}";
	else
		USER="${GREEN}\u${RESET}";
	fi;

	# construct prompt
	PS1="${RESET}\n";
	PS1+="${EXT} ";
	PS1+="${OPEN}${TIME}${CLOSE} ";
	PS1+="${OPEN}${USER}${AT}${HOST}${CLOSE} ";
	PS1+="${OPEN}${PWD}${CLOSE}";

	if [ "${REPO_STATUS}" != "" ]; then
		PS1+=" ${OPEN}${YELLOW}${REPO_STATUS}${RESET}${CLOSE}";
	fi;

	# finish with \$ which shows # as root and $ otherwise
	PS1+="\n\$ ";
}

export PROMPT_COMMAND;
